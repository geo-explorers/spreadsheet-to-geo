---
phase: 01-cli-restructure-and-shared-infrastructure
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/geo-client.ts
  - src/parsers/entity-id-parser.ts
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-03
  - CLI-02

must_haves:
  truths:
    - "fetchEntityDetails() returns properties, relation IDs (with the relation's own ID), type assignments, and name for a known entity ID"
    - "fetchEntityDetails() returns backlinks (incoming relations) with the backlink relation's own ID"
    - "fetchEntityDetails() returns null for a non-existent entity ID"
    - "parseEntityIds() reads entity IDs from an Excel tab and validates 32-char hex format"
    - "parseEntityIds() rejects files with duplicate entity IDs (returns errors, not silent dedup)"
    - "parseEntityIds() trims whitespace and skips blank rows silently"
  artifacts:
    - path: "src/api/geo-client.ts"
      provides: "Entity detail query functions"
      exports: ["fetchEntityDetails"]
    - path: "src/parsers/entity-id-parser.ts"
      provides: "Excel-based entity ID parser with validation"
      exports: ["parseEntityIds"]
  key_links:
    - from: "src/api/geo-client.ts"
      to: "Geo GraphQL API"
      via: "executeQuery with ENTITY_DETAILS_QUERY"
      pattern: "ENTITY_DETAILS_QUERY"
    - from: "src/parsers/entity-id-parser.ts"
      to: "src/utils/cell-parsers.ts"
      via: "import isValidGeoId and cleanString"
      pattern: "import.*isValidGeoId.*cleanString"
---

<objective>
Add entity detail query infrastructure to the GraphQL client and create an entity ID parser for Excel-based delete/update inputs.

Purpose: Entity detail queries (INFRA-01, INFRA-02) are required by both delete (to find all triples to remove) and update (to compare current vs desired state). The entity ID parser (CLI-02 superseded, INFRA-03) provides validated entity ID lists from Excel files for delete and update operations.

Output: Extended `src/api/geo-client.ts` with fetchEntityDetails(), new `src/parsers/entity-id-parser.ts`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cli-restructure-and-shared-infrastructure/01-CONTEXT.md
@.planning/phases/01-cli-restructure-and-shared-infrastructure/01-RESEARCH.md
@src/api/geo-client.ts
@src/utils/cell-parsers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add entity detail query functions to GraphQL client</name>
  <files>src/api/geo-client.ts</files>
  <action>
    Add three things to the existing `src/api/geo-client.ts`:

    **1. EntityDetails interface**

    Define the return type for entity detail queries:
    ```typescript
    export interface EntityDetails {
      id: string;
      name: string | null;
      typeIds: string[];
      values: Array<{
        propertyId: string;
        text: string | null;
        boolean: boolean | null;
        float: number | null;
        datetime: string | null;
        point: string | null;
        schedule: string | null;
      }>;
      relations: Array<{
        id: string;        // Relation's own ID -- needed for deleteRelation()
        typeId: string;
        toEntity: { id: string; name: string | null };
      }>;
      backlinks: Array<{
        id: string;        // Backlink relation's own ID -- needed for deleteRelation()
        typeId: string;
        fromEntity: { id: string; name: string | null };
      }>;
    }
    ```

    **2. ENTITY_DETAILS_QUERY GraphQL query string**

    CRITICAL: Use the `relations` connection pattern (NOT `relationsList`) to get the relation's own `id` field. The `relationsList` pattern does NOT expose the relation row's own ID, which is needed for `Graph.deleteRelation({ id })`. Same for `backlinks` connection.

    ```graphql
    query EntityDetails($id: UUID!, $spaceId: UUID!) {
      entity(id: $id) {
        id
        name
        typeIds
        valuesList(filter: { spaceId: { is: $spaceId } }) {
          propertyId
          text
          boolean
          float
          datetime
          point
          schedule
        }
        relations(filter: { spaceId: { is: $spaceId } }) {
          nodes {
            id
            typeId
            toEntity {
              id
              name
            }
          }
        }
        backlinks(filter: { spaceId: { is: $spaceId } }) {
          nodes {
            id
            typeId
            fromEntity {
              id
              name
            }
          }
        }
      }
    }
    ```

    **3. fetchEntityDetails() function**

    Export an async function that calls executeQuery with the above query and transforms the response:

    ```typescript
    export async function fetchEntityDetails(
      entityId: string,
      spaceId: string,
      network: 'TESTNET' | 'MAINNET'
    ): Promise<EntityDetails | null> {
      try {
        const data = await executeQuery<{
          entity: {
            id: string;
            name: string | null;
            typeIds: string[];
            valuesList: EntityDetails['values'];
            relations: { nodes: EntityDetails['relations'] };
            backlinks: { nodes: EntityDetails['backlinks'] };
          } | null;
        }>(ENTITY_DETAILS_QUERY, { id: entityId, spaceId }, network);

        if (!data.entity) return null;

        return {
          id: data.entity.id,
          name: data.entity.name,
          typeIds: data.entity.typeIds,
          values: data.entity.valuesList,
          relations: data.entity.relations.nodes,
          backlinks: data.entity.backlinks.nodes,
        };
      } catch (error) {
        logger.warn(`Failed to fetch entity details for "${entityId}"`, {
          error: error instanceof Error ? error.message : String(error),
        });
        return null;
      }
    }
    ```

    Place the new code AFTER the existing exports (searchEntitiesByNames, searchTypesByNames, searchPropertiesByNames, testApiConnection) to minimize diff noise. Add the interface at the top with other interfaces. Add the query string after the existing query constants.

    Note: `executeQuery` is a private function in geo-client.ts but accessible within the same file. No changes needed to it.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Check:
    1. `EntityDetails` interface is exported
    2. `fetchEntityDetails` function is exported
    3. Query uses `relations(filter:) { nodes { id ... } }` pattern (NOT `relationsList`)
    4. Query uses `backlinks(filter:) { nodes { id ... } }` pattern
    5. Return type correctly maps `valuesList` -> `values` and unwraps `nodes`
  </verify>
  <done>
    fetchEntityDetails() returns complete entity details including properties, outgoing relations with their own IDs, incoming relations (backlinks) with their own IDs, and type assignments. Returns null for non-existent entities. Uses the correct connection pattern for relation IDs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create entity ID parser for Excel input</name>
  <files>src/parsers/entity-id-parser.ts</files>
  <action>
    Create `src/parsers/entity-id-parser.ts` following the pattern from 01-RESEARCH.md "Entity ID Parsing from Excel" section.

    The parser reads entity IDs from an Excel tab and validates them. It enforces these locked user decisions:
    - Entity IDs are 32-char hex strings
    - Header row required
    - Duplicate entity IDs reject the file (validation failure, not silent dedup)
    - Whitespace trimmed, blank rows silently skipped

    ```typescript
    import XLSX from 'xlsx';
    import { isValidGeoId, cleanString } from '../utils/cell-parsers.js';

    export interface EntityIdParseResult {
      ids: string[];
      errors: string[];
    }

    /**
     * Parse entity IDs from an Excel tab.
     * Expects a tab with a header row and one column of 32-char hex entity IDs.
     *
     * Behavior:
     * - Trims whitespace from each cell
     * - Skips blank rows silently
     * - Rejects duplicate IDs (returns error, does NOT silently dedup)
     * - Validates 32-char hex format via isValidGeoId()
     *
     * @param filePath - Path to the Excel file
     * @param tabName - Name of the tab containing entity IDs
     * @returns Object with validated ids array and errors array
     */
    export function parseEntityIds(filePath: string, tabName: string): EntityIdParseResult {
      const workbook = XLSX.readFile(filePath);
      const sheet = workbook.Sheets[tabName];

      if (!sheet) {
        return { ids: [], errors: [`Tab "${tabName}" not found in workbook`] };
      }

      const rows: Record<string, unknown>[] = XLSX.utils.sheet_to_json(sheet, { defval: '' });

      if (rows.length === 0) {
        return { ids: [], errors: ['No data rows found (only header row or empty tab)'] };
      }

      const ids: string[] = [];
      const seen = new Set<string>();
      const errors: string[] = [];

      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const rowNum = i + 2; // +1 for 0-index, +1 for header row

        // Get first column value
        const values = Object.values(row);
        const raw = values[0];
        if (raw === undefined || raw === null || raw === '') continue; // blank row -- skip silently

        const value = cleanString(String(raw));
        if (!value) continue; // whitespace-only row -- skip silently

        const id = value.toLowerCase();

        if (!isValidGeoId(id)) {
          errors.push(`Row ${rowNum}: "${value}" is not a valid entity ID (expected 32-char hex string)`);
          continue;
        }

        if (seen.has(id)) {
          errors.push(`Row ${rowNum}: Duplicate entity ID "${id}"`);
          continue;
        }

        seen.add(id);
        ids.push(id);
      }

      return { ids, errors };
    }
    ```

    Key implementation notes:
    - Use `XLSX.utils.sheet_to_json()` which automatically uses the first row as headers
    - `Object.values(row)[0]` gets the first column value regardless of header name
    - Lowercase the ID for consistent comparison (hex is case-insensitive)
    - Errors accumulate -- all are reported, not just the first one
    - If `errors.length > 0`, the caller should reject the file (per user decision: duplicate IDs = validation failure)
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Check:
    1. `EntityIdParseResult` interface is exported
    2. `parseEntityIds` function is exported
    3. Uses `isValidGeoId` from cell-parsers (not a custom regex)
    4. Duplicate detection uses a Set and produces an error (not silent dedup)
    5. Blank rows are skipped without error messages
    6. Row numbers in errors account for header row (+2 offset)
  </verify>
  <done>
    Entity ID parser reads IDs from an Excel tab, validates 32-char hex format, rejects duplicates with error messages, trims whitespace, and silently skips blank rows. Returns both valid IDs and accumulated errors for the caller to decide on rejection.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep "fetchEntityDetails" src/api/geo-client.ts` confirms function exists
3. `grep "EntityDetails" src/api/geo-client.ts` confirms interface exported
4. `grep "parseEntityIds" src/parsers/entity-id-parser.ts` confirms function exists
5. `grep "relationsList" src/api/geo-client.ts` returns NO matches in the new query (uses `relations` connection pattern)
6. `grep "isValidGeoId" src/parsers/entity-id-parser.ts` confirms reuse of existing validation
</verification>

<success_criteria>
- fetchEntityDetails() queries entity properties, outgoing relations with IDs, incoming relations (backlinks) with IDs, and type assignments
- fetchEntityDetails() returns null for non-existent entities
- GraphQL query uses `relations(filter:) { nodes { id } }` connection pattern (NOT relationsList)
- parseEntityIds() reads entity IDs from an Excel tab
- parseEntityIds() validates 32-char hex format using isValidGeoId()
- parseEntityIds() rejects duplicate IDs with error messages
- parseEntityIds() trims whitespace and skips blank rows silently
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-cli-restructure-and-shared-infrastructure/01-03-SUMMARY.md`
</output>
