---
phase: 01-cli-restructure-and-shared-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/index.ts
  - src/cli.ts
  - src/commands/upsert.ts
  - src/processors/entity-processor.ts
autonomous: true
requirements:
  - STRUC-01
  - STRUC-02
  - STRUC-03
  - STRUC-04
  - CLI-01

must_haves:
  truths:
    - "Running `geo-publish upsert <file>` produces identical pipeline behavior to the old `geo-publish <file>` command"
    - "CLI displays help text showing available subcommands (upsert, delete, update) with usage instructions"
    - "Running `geo-publish delete` or `geo-publish update` without required argument shows command-specific help (not an error)"
    - "Section headers in upsert output are unnumbered (no 'Step 1:', 'Step 2:' prefixes)"
    - "Confirmation uses interactive yes/no prompt instead of 5-second delay"
    - "Network resolves from GEO_NETWORK env var with --network flag override"
    - "Upsert pipeline shows inline progress counter ('Processing X/Y entities...') during entity map building"
  artifacts:
    - path: "src/cli.ts"
      provides: "CLI router with subcommand registration"
      contains: "program.command('upsert"
    - path: "src/commands/upsert.ts"
      provides: "Extracted upsert pipeline handler"
      exports: ["upsertCommand"]
    - path: "src/index.ts"
      provides: "Thin shebang entry point"
      contains: "#!/usr/bin/env node"
  key_links:
    - from: "src/index.ts"
      to: "src/cli.ts"
      via: "import statement"
      pattern: "import.*cli"
    - from: "src/cli.ts"
      to: "src/commands/upsert.ts"
      via: "dynamic import in action callback"
      pattern: "import.*commands/upsert"
    - from: "src/commands/upsert.ts"
      to: "src/processors/entity-processor.ts"
      via: "onProgress callback passed to buildEntityMap"
      pattern: "buildEntityMap.*onProgress|logger\\.progress"
---

<objective>
Extract the monolithic `src/index.ts` into a subcommand CLI architecture with the upsert pipeline moved to its own command handler.

Purpose: This is the foundational restructure that enables adding delete and update commands in Phases 2 and 3 without modifying existing upsert code. It also applies user decisions for improved CLI UX (unnumbered sections, interactive confirmation, env-based network config).

Output: Three files -- `src/index.ts` (thin entry), `src/cli.ts` (Commander.js router), `src/commands/upsert.ts` (full upsert pipeline).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cli-restructure-and-shared-infrastructure/01-CONTEXT.md
@.planning/phases/01-cli-restructure-and-shared-infrastructure/01-RESEARCH.md
@src/index.ts
@src/utils/logger.ts
@src/config/schema.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI router and extract upsert command</name>
  <files>src/index.ts, src/cli.ts, src/commands/upsert.ts</files>
  <action>
    **Step 1: Create `src/commands/upsert.ts`**

    Extract the entire `main()` function body (lines 48-213 of current index.ts) into a new file as `export async function upsertCommand(file: string, options: UpsertOptions): Promise<void>`.

    Define the `UpsertOptions` interface locally in the file:
    ```typescript
    interface UpsertOptions {
      network?: string;
      dryRun: boolean;
      output: string;
      verbose: boolean;
      yes: boolean;
    }
    ```

    Copy all imports from index.ts that the pipeline uses (parseExcelFile, checkRequiredTabs, validateSpreadsheet, formatValidationErrors, buildEntityMap, buildRelations, buildOperationsBatch, formatBatchSummary, publishToGeo, validatePrivateKey, generatePublishReport, saveReport, printReportSummary, printPrePublishSummary, logger, setVerbose, PublishOptions type).

    Keep all behavior identical for now -- same step logic, same error handling, same exit codes. Do NOT change step header text yet (that happens in Task 2).

    **Step 2: Create `src/cli.ts`**

    Create the CLI router file with Commander.js subcommand structure. Follow the exact pattern from 01-RESEARCH.md "Pattern 1: Subcommand Handler Pattern":

    - Import `program` from `commander` and `dotenv`
    - Call `dotenv.config()` at module level
    - Set program name, description, version
    - Register `upsert <file>` subcommand with options: `--network`, `--dry-run`, `--output`, `--verbose`, `--yes`. Use dynamic import in action callback: `const { upsertCommand } = await import('./commands/upsert.js');`
    - Register `delete [file]` stub subcommand with same applicable options. The file argument MUST be optional (`[file]`, not `<file>`) so Commander does not emit a "missing required argument" error when invoked with no args. In the action callback, guard for the missing-file case:
      ```typescript
      const deleteCmd = program.command('delete')
        .argument('[file]', 'Path to Excel (.xlsx) file with entity IDs')
        // ... options ...
        .action(async (file?: string) => {
          if (!file) {
            deleteCmd.help();    // shows command-specific help and exits
            return;
          }
          console.error('Delete command is not yet implemented. Coming in Phase 2.');
          process.exit(1);
        });
      ```
    - Register `update [file]` stub subcommand with the same pattern (optional `[file]` arg + action guard that calls `updateCmd.help()` when no file). Action prints "Update command is not yet implemented. Coming in Phase 3." and exits with code 1.
    - Call `program.parse()`

    Important: the `--network` option should NOT have a default value in Commander (unlike current code which defaults to 'TESTNET'). Network resolution happens in the command handler using the `resolveNetwork()` helper (see Task 2). Set the option as `.option('-n, --network <network>', 'Network to publish to (TESTNET or MAINNET)')` without a default.

    **Step 3: Reduce `src/index.ts` to thin entry point**

    Replace the entire content of index.ts with:
    ```typescript
    #!/usr/bin/env node
    import './cli.js';
    ```

    This keeps the shebang line for CLI execution and delegates everything to cli.ts. Verify that `package.json` `bin` field still points to `./dist/index.js`.

    **Important:** Do NOT change any import paths that reference `../config/schema.js` -- those will be updated in Plan 01-02.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify TypeScript compilation succeeds. Check that:
    1. `src/index.ts` is 2-3 lines (shebang + import)
    2. `src/cli.ts` registers three subcommands
    3. `src/commands/upsert.ts` exports `upsertCommand`
    4. No circular imports exist
    5. After building (`npx tsc`), run `node dist/index.js delete` (no file arg) and confirm it prints command-specific help text (not a Commander "missing required argument" error)
    6. Run `node dist/index.js update` (no file arg) and confirm the same help behavior
  </verify>
  <done>
    CLI router delegates to upsert command handler. Delete and update stubs show help when invoked without a file argument, print "not yet implemented" when invoked with a file, and all TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply user decisions to upsert command UX</name>
  <files>src/commands/upsert.ts, src/cli.ts, src/processors/entity-processor.ts</files>
  <action>
    Apply four locked user decisions to the extracted upsert command:

    **1. Unnumbered section headers** (locked decision)

    In `src/commands/upsert.ts`, replace all numbered section calls:
    - `logger.section('Step 1: Checking Structure')` -> `logger.section('Checking Structure')`
    - `logger.section('Step 2: Parsing Spreadsheet')` -> `logger.section('Parsing Spreadsheet')`
    - `logger.section('Step 3: Validating Data')` -> `logger.section('Validating Data')`
    - `logger.section('Step 4: Building Entity Map')` -> `logger.section('Building Entity Map')`
    - `logger.section('Step 5: Building Relations')` -> `logger.section('Building Relations')`
    - `logger.section('Step 6: Building Operations Batch')` -> `logger.section('Building Operations Batch')`
    - `logger.section('Step 7: Publishing')` -> `logger.section('Publishing')`

    **2. Interactive confirmation prompt** (locked decision: replaces 5-second delay)

    Add a `confirmAction()` helper function in `src/commands/upsert.ts` (or at the top of the file as a private function). Use Node.js built-in `readline`:

    ```typescript
    import * as readline from 'readline';

    async function confirmAction(message: string): Promise<boolean> {
      if (!process.stdin.isTTY) {
        throw new Error('Interactive confirmation required. Use --yes to skip confirmation in non-interactive environments.');
      }
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      });
      return new Promise((resolve) => {
        rl.question(`${message} (yes/no): `, (answer) => {
          rl.close();
          resolve(answer.toLowerCase() === 'yes' || answer.toLowerCase() === 'y');
        });
      });
    }
    ```

    Replace the current 5-second delay block:
    ```typescript
    // OLD:
    // await new Promise(resolve => setTimeout(resolve, 5000));

    // NEW:
    const confirmed = await confirmAction('About to publish to Geo. This action cannot be undone. Continue?');
    if (!confirmed) {
      logger.info('Publish cancelled by user.');
      process.exit(0);
    }
    ```

    **3. Network resolution from env var** (locked decision: GEO_NETWORK env var + --network flag override)

    Add a `resolveNetwork()` helper in `src/commands/upsert.ts`:

    ```typescript
    function resolveNetwork(flagValue?: string): 'TESTNET' | 'MAINNET' {
      const network = (flagValue || process.env.GEO_NETWORK || 'TESTNET').toUpperCase();
      if (network !== 'TESTNET' && network !== 'MAINNET') {
        throw new Error(`Invalid network: "${network}". Must be TESTNET or MAINNET.`);
      }
      return network as 'TESTNET' | 'MAINNET';
    }
    ```

    Update the upsert command to use this helper:
    ```typescript
    const network = resolveNetwork(options.network);
    ```

    Remove the old inline cast: `const network = options.network.toUpperCase() as 'TESTNET' | 'MAINNET';`

    Also update the title section to show the operation name:
    - `logger.section('Geo Publish')` -> `logger.section('Geo Publish - Upsert')`

    **4. Inline progress counter for longer operations** (locked decision)

    The `buildEntityMap()` function in `src/processors/entity-processor.ts` makes async API calls (`searchEntitiesByNames`, `searchTypesByNames`, `searchPropertiesByNames`) which are the longest-running operations in the pipeline. The existing `logger.progress()` utility (in `src/utils/logger.ts`) already supports single-line updating via `process.stdout.write('\r...')`.

    Add inline progress counters to `src/commands/upsert.ts` around the `buildEntityMap()` call. Since `buildEntityMap()` currently does its API work internally (the three `Promise.all` calls plus entity/type/property processing loops), the simplest correct approach is to add a progress counter wrapper in the upsert command that uses `logger.progress()`:

    In `src/commands/upsert.ts`, after calling `buildEntityMap()`, the entity processing is already done. However, the locked decision specifies showing "Processing X/Y entities..." during the operation itself. To achieve this without modifying `buildEntityMap()`'s signature (which would bleed into Plan 01-02's scope), add a `progressCallback` parameter to `buildEntityMap()`:

    In `src/processors/entity-processor.ts`, update `buildEntityMap()` to accept an optional progress callback:

    ```typescript
    export async function buildEntityMap(
      data: ParsedSpreadsheet,
      network: 'TESTNET' | 'MAINNET',
      onProgress?: (current: number, total: number, label: string) => void
    ): Promise<EntityMap> {
    ```

    Then in the `processEntities()` inner function, call the callback during the second pass (the main entity resolution loop):

    ```typescript
    // In processEntities(), pass the callback through:
    let processed = 0;
    const total = byName.size;
    for (const [normalized, data] of byName) {
      processed++;
      if (onProgress) onProgress(processed, total, 'entities');
      // ... existing entity resolution logic ...
    }
    ```

    In `src/commands/upsert.ts`, pass `logger.progress` as the callback:

    ```typescript
    const entityMap = await buildEntityMap(data, network, (current, total, label) => {
      logger.progress(current, total, `Processing ${current}/${total} ${label}...`);
    });
    ```

    This produces single-line updating output like "Processing 12/100 entities..." that overwrites itself on each iteration, matching the locked decision exactly.

    Also add `src/processors/entity-processor.ts` to the files list for this task since it gets the optional `onProgress` parameter.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Grep for "Step [0-9]" in src/commands/upsert.ts to confirm no numbered sections remain. Grep for "setTimeout" to confirm 5-second delay is removed. Grep for "resolveNetwork" to confirm the helper is used. Grep for "onProgress" in src/processors/entity-processor.ts to confirm the callback parameter exists. Grep for "logger.progress" in src/commands/upsert.ts to confirm the progress counter is wired up.
  </verify>
  <done>
    Upsert command uses unnumbered section headers, interactive yes/no confirmation prompt (with TTY check), env-based network resolution with flag override, and inline progress counter during entity processing. No numbered steps remain. No 5-second delay remains.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `node dist/index.js --help` shows program with upsert, delete, update subcommands
3. `node dist/index.js upsert --help` shows upsert-specific options
4. `node dist/index.js delete --help` shows delete-specific help text
5. `node dist/index.js update --help` shows update-specific help text
6. `node dist/index.js delete` (no file arg) shows command-specific help, NOT a "missing required argument" error
7. `node dist/index.js update` (no file arg) shows command-specific help, NOT a "missing required argument" error
8. `grep -r "Step [0-9]" src/commands/` returns no matches (unnumbered sections)
9. `grep -r "setTimeout.*5000" src/` returns no matches (no 5-second delay)
10. `grep "resolveNetwork" src/commands/upsert.ts` confirms network helper usage
11. `grep "logger.progress\|process.stdout.write.*Processing" src/commands/upsert.ts` confirms inline progress counter usage
</verification>

<success_criteria>
- src/index.ts is a thin 2-line entry point (shebang + import)
- src/cli.ts registers three subcommands with appropriate options
- src/commands/upsert.ts contains the full upsert pipeline, unchanged in behavior except for the four UX improvements
- Delete and update stubs show help when invoked without args, print "not yet implemented" when given a file
- TypeScript compiles without errors
- All user-locked decisions implemented: unnumbered sections, interactive prompt, env-based network, inline progress counter
</success_criteria>

<output>
After completion, create `.planning/phases/01-cli-restructure-and-shared-infrastructure/01-01-SUMMARY.md`
</output>
