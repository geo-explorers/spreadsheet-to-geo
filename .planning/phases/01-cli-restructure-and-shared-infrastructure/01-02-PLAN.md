---
phase: 01-cli-restructure-and-shared-infrastructure
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/config/schema.ts
  - src/config/types.ts
  - src/config/upsert-types.ts
  - src/publishers/publish-report.ts
  - src/publishers/report.ts
  - src/commands/upsert.ts
  - src/parsers/excel-parser.ts
  - src/parsers/validators.ts
  - src/processors/entity-processor.ts
  - src/processors/relation-builder.ts
  - src/processors/batch-builder.ts
autonomous: true
requirements:
  - STRUC-05
  - CLI-03

must_haves:
  truths:
    - "Shared types (Metadata, PublishOptions, ValidationError, etc.) are importable from src/config/types.ts"
    - "Upsert-specific types (ParsedSpreadsheet, TypeDefinition, EntityMap, etc.) are importable from src/config/upsert-types.ts"
    - "OperationReport discriminated union in src/config/types.ts supports upsert, delete, and update operation types"
    - "Report saving uses generalized naming: {operation}-{timestamp}.json"
    - "All existing modules compile without errors after import path updates"
    - "No circular dependencies between types.ts and upsert-types.ts"
  artifacts:
    - path: "src/config/types.ts"
      provides: "Shared type definitions for all operations"
      contains: "OperationReport"
    - path: "src/config/upsert-types.ts"
      provides: "Upsert-specific type definitions"
      contains: "ParsedSpreadsheet"
    - path: "src/publishers/report.ts"
      provides: "Generalized report save/load infrastructure"
      exports: ["saveOperationReport"]
  key_links:
    - from: "src/config/upsert-types.ts"
      to: "src/config/types.ts"
      via: "import type for shared types"
      pattern: "import type.*from.*types"
    - from: "src/commands/upsert.ts"
      to: "src/publishers/report.ts"
      via: "import for report saving"
      pattern: "import.*report"
    - from: "src/publishers/report.ts"
      to: "src/config/types.ts"
      via: "import OperationReport type"
      pattern: "import type.*OperationReport"
---

<objective>
Split the monolithic `src/config/schema.ts` type definitions into shared and upsert-specific modules, and create a generalized reporting infrastructure with a discriminated union type covering all operation types.

Purpose: Clean type boundaries prevent future operations (delete, update) from coupling to upsert-specific types. The generalized report infrastructure provides consistent audit trails across all operations.

Output: `src/config/types.ts` (shared types), `src/config/upsert-types.ts` (upsert-specific), `src/publishers/report.ts` (generalized reports). All existing imports updated.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cli-restructure-and-shared-infrastructure/01-CONTEXT.md
@.planning/phases/01-cli-restructure-and-shared-infrastructure/01-RESEARCH.md
@.planning/phases/01-cli-restructure-and-shared-infrastructure/01-01-SUMMARY.md
@src/config/schema.ts
@src/publishers/publish-report.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Split schema.ts into shared and upsert-specific type modules</name>
  <files>src/config/types.ts, src/config/upsert-types.ts, src/config/schema.ts, src/commands/upsert.ts, src/parsers/excel-parser.ts, src/parsers/validators.ts, src/processors/entity-processor.ts, src/processors/relation-builder.ts, src/processors/batch-builder.ts</files>
  <action>
    **Step 1: Create `src/config/types.ts` with shared types**

    Move these types/constants from schema.ts to types.ts (they are used by multiple operations or are operation-agnostic):
    - `Metadata` interface
    - `PublishOptions` interface
    - `PublishResult` interface -- but update `summary` field to be generic: `summary: Record<string, number>` instead of `BatchSummary`. Or better: make PublishResult generic enough by keeping `summary` as `BatchSummary | Record<string, number>` -- actually simplest approach: keep PublishResult with the current summary type but move BatchSummary to shared too since delete/update will have their own summary types. Decision: move PublishResult to shared with `summary` typed as a generic record, and keep BatchSummary in upsert-types.
    - `ValidationSeverity` type
    - `ValidationError` interface
    - `ValidationResult` interface
    - `STANDARD_COLUMNS` constant
    - `SPECIAL_TABS` constant
    - `REQUIRED_TABS` constant

    Also add the new generalized report types (per 01-RESEARCH.md "Pattern 4"):
    - `ReportBase` interface with fields: operationType, timestamp, success, network, spaceId, dryRun, transactionHash?, error?
    - `UpsertReport` extending ReportBase with operationType: 'upsert' and upsert-specific summary/details
    - `DeleteReport` extending ReportBase with operationType: 'delete' and placeholder summary/details (to be filled in Phase 2)
    - `UpdateReport` extending ReportBase with operationType: 'update' and placeholder summary/details (to be filled in Phase 3)
    - `OperationReport` discriminated union: `UpsertReport | DeleteReport | UpdateReport`

    The UpsertReport should capture the existing PublishReport structure from publish-report.ts, adapted to the new base. Keep `summary` and `details` fields matching the current report content.

    Update `PublishResult` to remove the `summary: BatchSummary` field -- instead it should have a generic shape. Actually, the cleanest approach: keep `PublishResult` in shared types with `summary` as an optional `Record<string, number>` since each operation populates it differently. The upsert command will cast/assert as needed.

    Actually, the simplest correct approach that avoids breaking changes: Move `PublishResult` to types.ts as-is but change `summary` to type `BatchSummary` imported from upsert-types. No -- that creates a dependency from shared to upsert-specific. Instead:

    Final decision for PublishResult: Make it generic or simply keep it in upsert-types since it references BatchSummary. Move to upsert-types.ts along with BatchSummary.

    **Shared types (types.ts):**
    - Metadata
    - PublishOptions
    - ValidationSeverity, ValidationError, ValidationResult
    - STANDARD_COLUMNS, SPECIAL_TABS, REQUIRED_TABS
    - ReportBase, UpsertReport, DeleteReport, UpdateReport, OperationReport (new)

    **Upsert-specific types (upsert-types.ts):**
    - TypeDefinition
    - PropertyDefinition
    - SpreadsheetEntity
    - ParsedSpreadsheet
    - EntityAction
    - ResolvedEntity, ResolvedType, ResolvedProperty
    - EntityMap
    - OperationsBatch
    - BatchSummary
    - PublishResult (references BatchSummary)

    Note: `upsert-types.ts` imports NOTHING from `types.ts` (no circular risk). If any upsert-specific type needs a shared type, use `import type` from types.ts (one-directional dependency is fine).

    The `Op` type import from geo-sdk stays in upsert-types.ts (OperationsBatch uses it).

    **Step 2: Delete `src/config/schema.ts`**

    Remove the original file after types are split.

    **Step 3: Update all import paths across the codebase**

    Every file that currently imports from `'../config/schema.js'` (or `'./config/schema.js'`) must be updated:

    - `src/commands/upsert.ts`: imports both shared types (PublishOptions) and upsert types (ParsedSpreadsheet, etc.)
    - `src/parsers/excel-parser.ts`: imports upsert types (ParsedSpreadsheet, TypeDefinition, PropertyDefinition, SpreadsheetEntity, SPECIAL_TABS) and shared types (Metadata, REQUIRED_TABS)
    - `src/parsers/validators.ts`: imports upsert types + shared types (ValidationError, ValidationResult, ValidationSeverity)
    - `src/processors/entity-processor.ts`: imports upsert types (EntityMap, ResolvedEntity, etc.)
    - `src/processors/relation-builder.ts`: imports upsert types (EntityMap, PropertyDefinition)
    - `src/processors/batch-builder.ts`: imports upsert types (OperationsBatch, BatchSummary, etc.)
    - `src/publishers/publish-report.ts`: imports shared types + upsert types

    For each file, change `from '../config/schema.js'` to the appropriate combination of `from '../config/types.js'` and/or `from '../config/upsert-types.js'`.

    Use `import type` for all type-only imports to avoid runtime circular dependencies.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation succeeds. Verify:
    1. `src/config/schema.ts` no longer exists
    2. `src/config/types.ts` exports shared types and OperationReport
    3. `src/config/upsert-types.ts` exports upsert-specific types
    4. No file imports from `'../config/schema.js'` anymore
    5. grep for `OperationReport` in types.ts confirms the discriminated union exists
  </verify>
  <done>
    Types cleanly split with no circular dependencies. All modules compile. Shared types importable from types.ts, upsert-specific from upsert-types.ts. OperationReport discriminated union defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create generalized report infrastructure</name>
  <files>src/publishers/report.ts, src/publishers/publish-report.ts, src/commands/upsert.ts</files>
  <action>
    **Step 1: Create `src/publishers/report.ts`**

    Create a new generalized report module following the pattern from 01-RESEARCH.md "Generalized Report Save Function":

    ```typescript
    import * as fs from 'fs';
    import * as path from 'path';
    import type { OperationReport } from '../config/types.js';
    import { logger } from '../utils/logger.js';

    /**
     * Save operation report to disk
     * Naming: {operation}-{timestamp}.json or {operation}-dryrun-{timestamp}.json
     */
    export function saveOperationReport(report: OperationReport, outputDir: string): string {
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      const timestamp = report.timestamp
        .replace(/:/g, '-')
        .replace(/\./g, '-');
      const dryRunSuffix = report.dryRun ? '-dryrun' : '';
      const filename = `${report.operationType}${dryRunSuffix}-${timestamp}.json`;
      const filepath = path.join(outputDir, filename);

      fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
      logger.success(`Report saved: ${filepath}`);

      return filepath;
    }
    ```

    **Step 2: Update `src/publishers/publish-report.ts`**

    This file keeps the upsert-specific report generation logic (generatePublishReport, printReportSummary, printPrePublishSummary) but needs these changes:

    1. Update `PublishReport` interface to match the `UpsertReport` shape from types.ts. Since UpsertReport in types.ts IS the generalized version of PublishReport, update `generatePublishReport()` to return a `UpsertReport` (imported from types.ts) instead of the local `PublishReport` interface.

    2. Remove the local `PublishReport` interface definition -- use `UpsertReport` from types.ts instead.

    3. Update `saveReport()` to delegate to `saveOperationReport()` from report.ts, or simply remove `saveReport()` and have the upsert command call `saveOperationReport()` directly.

    4. Update `printReportSummary()` to accept `UpsertReport` instead of `PublishReport`.

    5. In `generatePublishReport()`, add the ReportBase fields: `operationType: 'upsert'`, `dryRun: false` (caller should set this), `network`, `spaceId`.

    **Step 3: Update `src/commands/upsert.ts`**

    Update imports to use:
    - `UpsertReport` from types.ts (instead of PublishReport from publish-report.ts)
    - `saveOperationReport` from report.ts (instead of saveReport from publish-report.ts)

    In the dry-run report generation, ensure `dryRun: true` is set on the report.
    In the normal publish report generation, ensure `dryRun: false` is set.

    The report is now saved via `saveOperationReport(report, options.output)` using the new generalized naming convention.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify compilation. Check:
    1. `src/publishers/report.ts` exports `saveOperationReport`
    2. `generatePublishReport()` returns a `UpsertReport` with all ReportBase fields populated
    3. Report filename follows `{operation}-{timestamp}.json` pattern (not old `publish-report-{timestamp}-{status}.json`)
    4. grep for `saveOperationReport` in src/commands/upsert.ts confirms usage
  </verify>
  <done>
    Generalized report infrastructure in place. UpsertReport conforms to OperationReport discriminated union. Reports saved with `{operation}-{timestamp}.json` naming. Old `saveReport()` replaced by `saveOperationReport()`.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/config/schema.ts` does not exist
3. `src/config/types.ts` exports OperationReport, ReportBase, UpsertReport, DeleteReport, UpdateReport, Metadata, PublishOptions, ValidationError, ValidationResult
4. `src/config/upsert-types.ts` exports ParsedSpreadsheet, TypeDefinition, PropertyDefinition, SpreadsheetEntity, EntityMap, OperationsBatch, BatchSummary
5. `src/publishers/report.ts` exports saveOperationReport
6. No file imports from `config/schema.js`
7. `grep -r "config/schema" src/` returns no matches
</verification>

<success_criteria>
- Type definitions cleanly split into shared (types.ts) and upsert-specific (upsert-types.ts) with no circular dependencies
- OperationReport discriminated union defined with upsert, delete, update variants
- Generalized report save function uses `{operation}-{timestamp}.json` naming convention
- All existing modules compile without errors after import migration
- Upsert command uses the new report infrastructure
</success_criteria>

<output>
After completion, create `.planning/phases/01-cli-restructure-and-shared-infrastructure/01-02-SUMMARY.md`
</output>
