---
phase: 03-bulk-update
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/commands/update.ts
  - src/publishers/update-report.ts
  - src/cli.ts
autonomous: true
requirements: [UPD-01, UPD-02, UPD-03, UPD-04, UPD-05, UPD-06]

must_haves:
  truths:
    - "Running `geo-publish update spreadsheet.xlsx` parses the spreadsheet, resolves entities by name, computes diffs, and publishes only changed values"
    - "All entity names AND relation target names are validated upfront before any diff or publish work begins"
    - "Running with --dry-run prints per-entity diffs and a summary without writing to Geo"
    - "Running without --yes prompts for confirmation before publishing"
    - "The --additive flag only adds new relation targets, never removes existing ones"
    - "--verbose and --quiet are mutually exclusive (hard error if both passed)"
    - "Entities with zero changes appear as 'skipped' in the report"
    - "Summary report shows counts of entities updated, properties set, relations added, relations removed"
  artifacts:
    - path: "src/commands/update.ts"
      provides: "Update command handler with four-phase pipeline (validate -> diff -> confirm -> publish)"
      min_lines: 150
    - path: "src/publishers/update-report.ts"
      provides: "Update-specific report generation and terminal diff formatting"
      min_lines: 60
    - path: "src/cli.ts"
      provides: "Updated CLI router with full update subcommand registration (--additive, --quiet flags)"
  key_links:
    - from: "src/commands/update.ts"
      to: "src/processors/update-diff.ts"
      via: "computeEntityDiffs() for diff phase"
      pattern: "computeEntityDiffs"
    - from: "src/commands/update.ts"
      to: "src/api/geo-client.ts"
      via: "searchEntitiesByNames() for entity resolution, fetchEntityDetails() indirectly via diff engine"
      pattern: "searchEntitiesByNames"
    - from: "src/commands/update.ts"
      to: "src/publishers/publisher.ts"
      via: "publishToGeo() for atomic publish of all update ops"
      pattern: "publishToGeo"
    - from: "src/commands/update.ts"
      to: "src/utils/cli-helpers.ts"
      via: "confirmAction(), resolveNetwork() shared helpers"
      pattern: "import.*cli-helpers"
    - from: "src/cli.ts"
      to: "src/commands/update.ts"
      via: "dynamic import in Commander action callback"
      pattern: "import.*commands/update"
    - from: "src/commands/update.ts"
      to: "src/publishers/update-report.ts"
      via: "generateUpdateReport(), printDiffOutput(), printUpdateSummary()"
      pattern: "import.*update-report"
    - from: "src/commands/update.ts"
      to: "src/publishers/report.ts"
      via: "saveOperationReport() for writing report file"
      pattern: "saveOperationReport"
---

<objective>
Create the update command handler that orchestrates the four-phase pipeline (validate -> diff -> confirm -> publish), wire it into the CLI with all flags, and build update-specific report generation.

Purpose: This plan connects the diff engine (Plan 01) to the existing infrastructure (parser, publisher, reports) to deliver the complete `geo-publish update` command.

Output: Working `geo-publish update spreadsheet.xlsx` command with --dry-run, --yes, --additive, --verbose, --quiet flags and JSON report output.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bulk-update/03-CONTEXT.md
@.planning/phases/03-bulk-update/03-RESEARCH.md
@.planning/phases/03-bulk-update/03-01-SUMMARY.md

@src/commands/upsert.ts
@src/cli.ts
@src/config/types.ts
@src/config/update-types.ts
@src/config/upsert-types.ts
@src/processors/update-diff.ts
@src/utils/cli-helpers.ts
@src/api/geo-client.ts
@src/parsers/excel-parser.ts
@src/parsers/validators.ts
@src/processors/batch-builder.ts
@src/publishers/publisher.ts
@src/publishers/report.ts
@src/publishers/publish-report.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create update command handler with four-phase pipeline</name>
  <files>
    src/commands/update.ts
    src/cli.ts
  </files>
  <action>
    **1. Create `src/commands/update.ts`** -- The update command handler implementing the four-phase pipeline from CONTEXT.md.

    **Imports:**
    - `parseExcelFile`, `checkRequiredTabs` from `../parsers/excel-parser.js`
    - `validateSpreadsheet`, `formatValidationErrors` from `../parsers/validators.js`
    - `searchEntitiesByNames`, `searchPropertiesByNames` from `../api/geo-client.js`
    - `computeEntityDiffs` from `../processors/update-diff.js`
    - `Graph`, `type Op` from `@geoprotocol/geo-sdk`
    - `resolveNetwork`, `confirmAction` from `../utils/cli-helpers.js`
    - `generateUpdateReport`, `printDiffOutput`, `printUpdateSummary` from `../publishers/update-report.js`
    - `saveOperationReport` from `../publishers/report.js`
    - `validatePrivateKey` from `../publishers/publisher.js`
    - `publishToGeo` from `../publishers/publisher.js`
    - `normalizeEntityName`, `parseMultiValueList` from `../utils/cell-parsers.js`
    - `logger`, `setVerbose` from `../utils/logger.js`
    - Types: `UpdateOptions` from `../config/update-types.js`, `PublishOptions` from `../config/types.js`

    **Interface:**
    ```typescript
    interface UpdateCommandOptions {
      network?: string;
      dryRun: boolean;
      output: string;
      verbose: boolean;
      quiet: boolean;
      yes: boolean;
      additive: boolean;
    }
    ```

    **`export async function updateCommand(file: string, options: UpdateCommandOptions): Promise<void>`**

    Implementation (four-phase pipeline per CONTEXT.md locked decision):

    **Preamble:**
    - Validate --verbose and --quiet are mutually exclusive. If both passed, hard-error: `"--verbose and --quiet are mutually exclusive"`.
    - Set verbose mode via `setVerbose(options.verbose)`.
    - Resolve network via `resolveNetwork(options.network)`.
    - Log header: file, network, dry-run, additive mode.
    - Validate file exists.

    **Phase 1: VALIDATE**
    - `checkRequiredTabs(filePath)` -- hard-error if missing.
    - `parseExcelFile(filePath)` -- get parsed spreadsheet.
    - Check `operationType` field on metadata: if present and not 'UPDATE', log warning: `"Spreadsheet Operation type is '${metadata.operationType}' but running update command. Proceeding."` (per research open question #1: warn, don't error).
    - `validateSpreadsheet(parsed)` -- reuse existing validation. Hard-error if invalid.
    - Collect ALL entity names from spreadsheet rows.
    - Collect ALL relation target names from spreadsheet relation cells (parse with `parseMultiValueList` for comma/semicolon-separated names).
    - Combine into one deduplicated list of names to resolve.
    - `searchEntitiesByNames(allNames, metadata.spaceId, network)` -- resolve all names.
    - Check for unresolved names. If ANY entity row name is unresolved, hard-error listing all unresolved names. If ANY relation target name is unresolved, hard-error listing all unresolved targets. This is the "all names validated upfront" locked decision.
    - `searchPropertiesByNames(propertyNames, network)` -- resolve property IDs (needed for diff engine to match property IDs to entity details).
    - Build a resolved-entities map: normalized name -> { id, name }.
    - Build a resolved-properties map: normalized name -> { id, dataType, geoDataType } (combine spreadsheet PropertyDefinition with API-resolved property info).

    **Phase 2: DIFF**
    - Call `computeEntityDiffs(parsed.entities, resolvedEntities, resolvedProperties, metadata.spaceId, network, { additive: options.additive, verbose: options.verbose })`.
    - This returns `{ diffs, summary }`.

    **--dry-run gate:**
    - If `options.dryRun`:
      - Call `printDiffOutput(diffs, summary, options)` to show terminal output.
      - Call `generateUpdateReport(diffs, summary, metadata, network, true)` to build report.
      - Call `saveOperationReport(report, options.output)` to save.
      - Log "Dry run complete -- no changes were made."
      - `process.exit(0)`.

    **Phase 3: CONFIRM**
    - Call `printDiffOutput(diffs, summary, options)` to show the diff.
    - If summary shows zero changes: log "No changes detected -- nothing to publish." and exit 0.
    - If `!options.yes`:
      - Call `confirmAction('Apply these changes to Geo? This action cannot be undone.')`.
      - If declined, log "Update cancelled by user." and exit 0.

    **Phase 4: PUBLISH**
    - Check PRIVATE_KEY env var (same pattern as upsert).
    - Build ops array from diffs:
      - For each entity diff with status 'updated':
        - If scalarChanges.length > 0: `Graph.updateEntity({ id: entityDiff.entityId, values: scalarChanges.map(c => ({ property: c.propertyId, ...c.typedValue })) })` -- push ops.
        - For each relation toAdd: `Graph.createRelation({ fromEntity: entityDiff.entityId, toEntity: rel.entityId, type: rel.propertyId })` -- push ops.
        - For each relation toRemove: `Graph.deleteRelation({ id: rel.relationId })` -- push ops.
    - All ops go into a single array for atomic publish (per research: single publishEdit call).
    - Build an `OperationsBatch`-compatible object. NOTE: publishToGeo currently expects `OperationsBatch` from upsert-types.ts. The update command should pass `{ ops: allOps, summary: batchSummary }` where batchSummary is a minimal object satisfying the type. Alternatively, since we just need to pass ops to the SDK, call publishToGeo with a compatible batch. Check the publisher.ts interface -- it takes `OperationsBatch` which includes a `BatchSummary`. For the update command, create a minimal compatible batch with zeroed upsert-specific fields, OR refactor publishToGeo to accept raw `Op[]`. Claude's discretion on the cleanest approach -- a simple adapter is fine.
    - Call `publishToGeo(batch, metadata, privateKey, publishOptions)`.
    - Generate and save report via `generateUpdateReport()` and `saveOperationReport()`.
    - Call `printUpdateSummary(summary, result)` for final output.
    - Exit with appropriate code.

    **Error handling:** Wrap entire pipeline in try/catch matching upsert's pattern. Log errors with `logger.error()`, show stack in verbose mode, exit 1.

    **2. Update `src/cli.ts`** -- Replace the update command stub with the real implementation.

    Replace the current update subcommand block (lines ~58-75) with:

    ```typescript
    const updateCmd = program
      .command('update')
      .argument('[file]', 'Path to Excel (.xlsx) file with entity updates')
      .description('Update entity properties from an Excel spreadsheet')
      .option('-n, --network <network>', 'Network to publish to (TESTNET or MAINNET)')
      .option('--dry-run', 'Validate, diff, and preview without publishing', false)
      .option('-o, --output <dir>', 'Output directory for reports', './reports')
      .option('-v, --verbose', 'Show unchanged relation targets in diff output', false)
      .option('-q, --quiet', 'Suppress diff and progress, only show errors and summary', false)
      .option('-y, --yes', 'Skip confirmation prompt', false)
      .option('--additive', 'Only add new relation targets, never remove existing ones', false)
      .action(async (file?: string) => {
        if (!file) {
          updateCmd.help();
          return;
        }
        const { updateCommand } = await import('./commands/update.js');
        await updateCommand(file, {
          network: updateCmd.opts().network,
          dryRun: updateCmd.opts().dryRun,
          output: updateCmd.opts().output,
          verbose: updateCmd.opts().verbose,
          quiet: updateCmd.opts().quiet,
          yes: updateCmd.opts().yes,
          additive: updateCmd.opts().additive,
        });
      });
    ```

    Note the new flags: `--additive`, `--quiet` (`-q`). The `--verbose` description changes to match the update context. The `--dry-run` description includes "diff" to reflect the four-phase pipeline.
  </action>
  <verify>
    <automated>cd /root/geo-learnings/spreadsheet-to-geo && npx tsx src/cli.ts update --help 2>&1</automated>
    <manual>Verify update --help shows all flags: --dry-run, --yes, --verbose, --quiet, --additive, --network, --output</manual>
  </verify>
  <done>
    - `src/commands/update.ts` implements the four-phase pipeline: validate -> diff -> confirm -> publish
    - All entity names AND relation target names are validated upfront in Phase 1
    - --dry-run stops after diff phase with full output
    - --yes skips confirmation prompt
    - --verbose and --quiet are mutually exclusive (hard error)
    - --additive flag passed through to diff engine
    - All update ops collected into single array for atomic publish
    - `src/cli.ts` registers the update subcommand with all flags including --additive and --quiet
    - `geo-publish update --help` displays all available options
  </done>
</task>

<task type="auto">
  <name>Task 2: Create update report generation and terminal output formatting</name>
  <files>
    src/publishers/update-report.ts
  </files>
  <action>
    Create `src/publishers/update-report.ts` -- Update-specific report generation and terminal diff formatting.

    **Imports:**
    - `EntityDiff`, `DiffSummary`, `UpdateOptions` from `../config/update-types.js`
    - `UpdateReport` from `../config/types.js`
    - `Metadata` from `../config/types.js`
    - `logger` from `../utils/logger.js`
    - `chalk` (for terminal colors in diff output)

    **Exports:**

    1. **`function generateUpdateReport(diffs, summary, metadata, network, dryRun): UpdateReport`**
       - Build an `UpdateReport` object (from types.ts) with:
         - `operationType: 'update'`
         - `timestamp: new Date().toISOString()`
         - `success: true` (caller can override)
         - `network`, `spaceId: metadata.spaceId`, `dryRun`
         - `summary`: `{ entitiesUpdated, propertiesUpdated, relationsAdded, relationsRemoved }` from DiffSummary
         - `details.entities`: For each entity diff, include `{ name, id, changes }` where `changes` is an array of human-readable strings like `"Set 'Description' = 'New value' (was 'Old value')"`, `"Add relation 'Employer' -> 'Anthropic'"`, `"Remove relation 'Employer' -> 'Old Corp'"`.
       - Entities with status 'skipped' get `changes: ['(no changes)']`.

    2. **`function printDiffOutput(diffs: EntityDiff[], summary: DiffSummary, options: { verbose: boolean, quiet: boolean }): void`**
       - If `options.quiet`: only print summary counts (skip per-entity details).
       - Otherwise, for each entity diff:
         - Print entity name and status.
         - For each scalar change with type 'set': print `  SET {propertyName}: "{oldValue}" -> "{newValue}"` (use chalk.yellow for property name, chalk.red for old, chalk.green for new).
         - For each relation change with toAdd: print `  ADD {propertyName} -> {entityName}` (chalk.green).
         - For each relation change with toRemove: print `  DEL {propertyName} -> {entityName}` (chalk.red).
         - If `options.verbose`: also print unchanged relations with `  ~   {propertyName} -> {entityName}` (chalk.gray).
         - For entities with status 'skipped': print `  (no changes)` (chalk.gray).
       - After all entities, print a separator line then summary counts.
       - Diff format is Claude's discretion per CONTEXT.md -- this is the recommended format but Claude can adjust for readability.

    3. **`function printUpdateSummary(summary: DiffSummary, publishResult?: { success: boolean, transactionHash?: string }): void`**
       - Print final summary after publish:
         - Entities updated: X
         - Entities skipped: Y
         - Properties set: Z
         - Relations added: A
         - Relations removed: B
         - Transaction hash (if available)
       - Use logger.section() and logger.keyValue() for consistent formatting with upsert.
  </action>
  <verify>
    <automated>cd /root/geo-learnings/spreadsheet-to-geo && npx tsx -e "import { generateUpdateReport, printDiffOutput, printUpdateSummary } from './src/publishers/update-report.js'; console.log('update-report.ts loads OK')" 2>&1</automated>
    <manual>Verify the module exports resolve correctly</manual>
  </verify>
  <done>
    - `src/publishers/update-report.ts` exports `generateUpdateReport`, `printDiffOutput`, `printUpdateSummary`
    - `generateUpdateReport()` produces an `UpdateReport` compatible with `saveOperationReport()`
    - Entities with zero changes appear in report as "skipped" (not omitted) per CONTEXT.md decision
    - Report includes both entity-level counts AND property-level detail per CONTEXT.md decision
    - Terminal diff output uses chalk for readability
    - --quiet mode suppresses per-entity details, only shows summary
    - --verbose mode shows unchanged relation targets
  </done>
</task>

</tasks>

<verification>
- `npx tsx src/cli.ts update --help` shows all flags: --dry-run, --yes, --verbose, --quiet, --additive, --network, --output
- `npx tsx src/cli.ts upsert --help` still works (no regression)
- `src/commands/update.ts` compiles and implements the four-phase pipeline
- `src/publishers/update-report.ts` compiles and its exports are importable
- All update ops (updateEntity + createRelation + deleteRelation) collected into single array for atomic publish
</verification>

<success_criteria>
- Complete `geo-publish update` command with --dry-run, --yes, --additive, --verbose, --quiet flags
- Four-phase pipeline: validate (with upfront name resolution), diff, confirm, publish
- Upfront validation of ALL entity names and relation targets (hard error on unresolved)
- Dry-run stops cleanly after diff phase with full output
- Atomic publish: all ops in single publishEdit call
- Update report saved as JSON with entity-level and property-level detail
- Terminal diff output with color-coded changes
- Entities with zero changes reported as "skipped"
</success_criteria>

<output>
After completion, create `.planning/phases/03-bulk-update/03-02-SUMMARY.md`
</output>
