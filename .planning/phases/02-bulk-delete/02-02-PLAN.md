---
phase: 02-bulk-delete
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/commands/delete.ts
  - src/cli.ts
autonomous: true
requirements:
  - DEL-01
  - DEL-02
  - DEL-08
  - DEL-09
  - DEL-10
  - DEL-11

must_haves:
  truths:
    - "Running geo-publish delete entities.xlsx --space <id> triggers the full delete pipeline"
    - "Entity IDs are parsed from Excel via parseEntityIds() and all must exist (fail-fast)"
    - "Dry-run mode displays entity names, property counts, and relation counts without executing"
    - "Pre-deletion snapshot is saved to .snapshots/ with timestamped JSON filename"
    - "Confirmation prompt appears before execution unless --force is passed"
    - "Progress reporting shows Processing X/Y during entity detail fetching"
    - "On failure, remaining-entities CSV is written and execution halts"
    - "Summary report shows counts of entities deleted, relations removed, properties unset"
    - "CLI delete subcommand has --space (required), --force, --dry-run, --network, --output flags"
  artifacts:
    - path: "src/commands/delete.ts"
      provides: "deleteCommand() handler with full delete pipeline"
      exports: ["deleteCommand"]
      min_lines: 100
    - path: "src/cli.ts"
      provides: "Updated delete subcommand with --space and --force flags"
      contains: "requiredOption.*--space"
  key_links:
    - from: "src/commands/delete.ts"
      to: "src/parsers/entity-id-parser.ts"
      via: "parseEntityIds() for input parsing"
      pattern: "parseEntityIds"
    - from: "src/commands/delete.ts"
      to: "src/api/geo-client.ts"
      via: "fetchEntityDetails() for validation and data fetching"
      pattern: "fetchEntityDetails"
    - from: "src/commands/delete.ts"
      to: "src/processors/delete-builder.ts"
      via: "buildDeleteOps() for operation generation"
      pattern: "buildDeleteOps"
    - from: "src/commands/delete.ts"
      to: "src/publishers/publisher.ts"
      via: "publishToGeo() for transaction submission"
      pattern: "publishToGeo"
    - from: "src/commands/delete.ts"
      to: "src/publishers/report.ts"
      via: "saveOperationReport() for report persistence"
      pattern: "saveOperationReport"
    - from: "src/cli.ts"
      to: "src/commands/delete.ts"
      via: "dynamic import in delete subcommand action"
      pattern: "import.*commands/delete"
---

<objective>
Implement the delete command handler and wire it into the CLI with all required flags, producing a complete delete pipeline from CSV input through entity validation, snapshot, operation building, confirmation, publishing, error recovery, and reporting.

Purpose: This is the user-facing integration that connects all the pieces (parser, API client, op builder, publisher, reporter) into a single CLI command with safety features (confirmation, dry-run, snapshots, fail-stop with remaining CSV).

Output: `src/commands/delete.ts` (command handler) and updated `src/cli.ts` (CLI wiring with --space and --force flags)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bulk-delete/02-RESEARCH.md
@.planning/phases/02-bulk-delete/02-01-SUMMARY.md

Key reference files:
@src/commands/upsert.ts (command handler pattern -- mirror this structure)
@src/cli.ts (CLI wiring -- update delete stub)
@src/parsers/entity-id-parser.ts (parseEntityIds -- reuse)
@src/api/geo-client.ts (fetchEntityDetails -- reuse)
@src/processors/delete-builder.ts (buildDeleteOps -- from Plan 01)
@src/config/delete-types.ts (DeleteOptions, DeleteBatch, DeleteSnapshot -- from Plan 01)
@src/config/types.ts (DeleteReport, Metadata, PublishOptions -- reuse)
@src/publishers/publisher.ts (publishToGeo -- reuse)
@src/publishers/report.ts (saveOperationReport -- reuse)
@src/utils/logger.ts (logger -- reuse)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement delete command handler</name>
  <files>src/commands/delete.ts</files>
  <action>
Create `src/commands/delete.ts` following the same pipeline structure as `upsert.ts`:

**Pipeline flow:** parse -> validate existence -> fetch details -> snapshot -> build ops -> dry-run OR (confirm -> publish -> report)

**Implementation details:**

1. **Imports:** Import `parseEntityIds` from entity-id-parser, `fetchEntityDetails` from geo-client, `buildDeleteOps` from delete-builder, `publishToGeo` and `validatePrivateKey` from publisher, `saveOperationReport` from report, `logger` and `setVerbose` from logger. Import types: `DeleteOptions` from delete-types, `DeleteReport`, `Metadata`, `PublishOptions` from types.

2. **resolveNetwork():** Copy from upsert.ts (same function -- flag > env > TESTNET default). Note: In a future refactor this could be shared, but for now mirror the upsert pattern.

3. **confirmDeletion():** Interactive confirmation using Node.js `readline` (same pattern as upsert.ts `confirmAction()`).
   - Show entity count and first 5 entity names as preview (per user decision)
   - Default is N (abort) -- require explicit `y` to proceed (per user decision)
   - Throw if `!process.stdin.isTTY` -- use `--force` for CI (per user decision)
   - Prompt wording (Claude's discretion): `"About to delete {N} entities. This will remove all properties, relations, and type assignments.\nEntities: {first 5 names}...\nProceed? (y/N): "`

4. **saveSnapshot():** Save pre-deletion JSON to `.snapshots/` directory.
   - Create `.snapshots/` if it doesn't exist (per user decision)
   - Timestamped filename: `delete-snapshot-{ISO timestamp with colons replaced by hyphens}.json` (per user decision)
   - Content: Full `EntityDetails[]` serialized as JSON (per user decision -- "full entity data")
   - Return the filepath for error messages (per user decision)

5. **writeRemainingCsv():** On failure, write unprocessed entity IDs to a CSV.
   - Header row: `entity_id`
   - One ID per line
   - Timestamped filename in the output directory (Claude's discretion)
   - Return filepath for logging

6. **deleteCommand(file, options):** Main pipeline:

   a. `setVerbose(options.verbose)`, resolve network, log header
   b. Validate file exists
   c. Parse entity IDs: `parseEntityIds(filePath, 'Sheet1')` -- use 'Sheet1' as default tab name (Excel default). If parsing returns errors, log them all and exit(1).
   d. Validate ALL entity IDs exist: For each ID, call `fetchEntityDetails(id, options.space, network)`. Use batched parallel calls (batch size 5-10) with progress reporting (`logger.progress(current, total, "Validating entities...")`). Collect null results as invalid. If ANY are null, log all invalid IDs and exit(1) (DEL-02: fail-fast, refuse to proceed).
   e. **Dry-run branch (DEL-08):** If `options.dryRun`, display a table with columns: Entity Name, Properties, Relations, Backlinks. Use `logger.table()`. Then generate and save a DeleteReport with `dryRun: true`. Exit(0).
   f. Save pre-deletion snapshot (DEL-09) to `.snapshots/`.
   g. Build delete ops: `buildDeleteOps(entityDetailsList)`.
   h. Log summary: `logger.keyValue('Entities', N)`, `logger.keyValue('Relations to delete', N)`, etc.
   i. Confirm deletion (unless `--force`).
   j. Validate PRIVATE_KEY (same as upsert.ts pattern).
   k. Publish: Create a `Metadata` object with `spaceId: options.space` and `spaceType: 'Personal'` (default -- per Open Question 3 in RESEARCH.md, defaulting to Personal is simplest for v1). Create `PublishOptions`. Call `publishToGeo()` with the DeleteBatch wrapped as `{ ops: batch.ops, summary: { ... } }`. Note: publishToGeo expects `OperationsBatch` from upsert-types -- create a compatible object with the ops array and a minimal summary (the publisher only uses `batch.ops` and `batch.summary` for logging).
   l. Generate DeleteReport and save via `saveOperationReport()`.
   m. Print final summary using `logger.table()` or `logger.keyValue()`.

   **Error handling (per user decisions):**
   - Wrap the publish step in try/catch
   - On failure: log the error, reference the snapshot path, write remaining-entities CSV, then exit(1)
   - Report partial state: what succeeded and what remains

   **Progress reporting (DEL-10):** Use `logger.progress()` during entity detail fetching (step d) and `logger.info()` line-by-line during the publish step.

**Important publisher compatibility note:** The publisher's `publishToGeo()` takes an `OperationsBatch` from upsert-types and a `Metadata` object. For the delete command:
- Create a minimal `OperationsBatch`-compatible object: `{ ops: deleteBatch.ops, summary: { typesCreated: 0, typesLinked: 0, propertiesCreated: 0, propertiesLinked: 0, entitiesCreated: 0, entitiesLinked: 0, relationsCreated: 0, imagesUploaded: 0, multiTypeEntities: [] } }` -- the publisher only reads `ops` and logs `summary`.
- Create a `Metadata` object: `{ spaceId: options.space, spaceType: 'Personal' }`. Default to 'Personal' space type for v1.
  </action>
  <verify>
    <automated>cd /Users/Vytautas/Documents/GitHub/spreadsheet-to-geo && npx tsc --noEmit</automated>
    <manual>Review delete.ts pipeline: parse -> validate -> fetch -> snapshot -> build ops -> confirm -> publish -> report</manual>
  </verify>
  <done>delete.ts exports deleteCommand() implementing the full delete pipeline with: entity ID parsing, existence validation, dry-run display, snapshot saving, confirmation prompt, publish, fail-stop error recovery with remaining CSV, and summary reporting</done>
</task>

<task type="auto">
  <name>Task 2: Wire delete command into CLI with required flags</name>
  <files>src/cli.ts</files>
  <action>
Update the delete subcommand stub in `src/cli.ts` to:

1. Add `--space` as a **required** option: `.requiredOption('-s, --space <id>', 'Target space ID (32-char hex)')` -- per Pattern 4 in RESEARCH.md
2. Add `--force` flag: `.option('-f, --force', 'Skip confirmation prompt (for CI/scripts)', false)` -- per user decision
3. Keep existing options: `--network`, `--dry-run`, `--output`, `--verbose`
4. Remove the `-y, --yes` option (replaced by `--force` which is the user's chosen name)
5. Update the action handler to dynamically import and call `deleteCommand`:

```typescript
const deleteCmd = program
  .command('delete')
  .argument('[file]', 'Path to Excel (.xlsx) file with entity IDs')
  .description('Delete entities listed in an Excel file')
  .requiredOption('-s, --space <id>', 'Target space ID (32-char hex)')
  .option('-n, --network <network>', 'Network to publish to (TESTNET or MAINNET)')
  .option('--dry-run', 'Preview deletions without executing', false)
  .option('-f, --force', 'Skip confirmation prompt (for CI/scripts)', false)
  .option('-o, --output <dir>', 'Output directory for reports', './reports')
  .option('-v, --verbose', 'Enable verbose logging', false)
  .action(async (file?: string, opts?: {
    space: string;
    network?: string;
    dryRun: boolean;
    force: boolean;
    output: string;
    verbose: boolean;
  }) => {
    if (!file) {
      deleteCmd.help();
      return;
    }
    const { deleteCommand } = await import('./commands/delete.js');
    await deleteCommand(file, {
      space: opts!.space,
      network: opts?.network,
      dryRun: opts!.dryRun,
      force: opts!.force,
      output: opts!.output,
      verbose: opts!.verbose,
    });
  });
```

**Key changes from the stub:**
- Replace `console.error('Delete command is not yet implemented...')` with real handler
- Add `.requiredOption()` for `--space` (Commander enforces this automatically)
- Add `--force` flag
- Remove `-y, --yes` (replaced by `--force`)
- Dynamic import pattern matches upsert command pattern
  </action>
  <verify>
    <automated>cd /Users/Vytautas/Documents/GitHub/spreadsheet-to-geo && npx tsc --noEmit</automated>
    <manual>Run `npx tsx src/cli.ts delete --help` and verify --space is listed as required and --force is available</manual>
  </verify>
  <done>CLI delete subcommand has --space (required), --force, --dry-run, --network, --output, --verbose flags and delegates to deleteCommand()</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx tsx src/cli.ts delete --help` shows --space as required, --force available
3. `src/commands/delete.ts` exists and exports `deleteCommand`
4. Delete pipeline follows: parse -> validate -> fetch details -> snapshot -> build ops -> confirm -> publish -> report
5. Dry-run mode displays entity table without executing (DEL-08)
6. Snapshot saved to `.snapshots/` with timestamped filename (DEL-09)
7. Progress reporting visible during entity fetching (DEL-10)
8. Confirmation prompt appears unless --force (user decision)
9. On failure: remaining-entities CSV written, execution halts, snapshot path referenced (user decision)
10. Summary report saved via saveOperationReport() (DEL-11)
</verification>

<success_criteria>
- Full delete pipeline functional: parse entity IDs from Excel, validate existence, fetch details, build ops, publish
- All safety features implemented: confirmation prompt, --force bypass, dry-run, pre-deletion snapshot, fail-stop with remaining CSV
- CLI properly wired with required --space flag and all options
- Reports generated for both dry-run and live execution
- Error handling stops on first failure and outputs remaining entities for re-run
</success_criteria>

<output>
After completion, create `.planning/phases/02-bulk-delete/02-02-SUMMARY.md`
</output>
