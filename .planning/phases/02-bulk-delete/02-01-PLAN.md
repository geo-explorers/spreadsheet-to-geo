---
phase: 02-bulk-delete
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/delete-types.ts
  - src/processors/delete-builder.ts
autonomous: true
requirements:
  - DEL-03
  - DEL-04
  - DEL-05
  - DEL-06
  - DEL-07

must_haves:
  truths:
    - "buildDeleteOps() converts EntityDetails[] into Op[] that blank every entity"
    - "All outgoing relations produce Graph.deleteRelation() ops"
    - "All incoming relations (backlinks) produce Graph.deleteRelation() ops"
    - "Duplicate relation IDs across entities are deduplicated (processed only once)"
    - "All property values produce Graph.updateEntity({ unset }) ops"
    - "Type assignment relations are included in the relation deletion set"
    - "Graph.deleteEntity() is NOT used anywhere"
  artifacts:
    - path: "src/config/delete-types.ts"
      provides: "DeleteOptions, DeleteSummary, DeleteBatch interfaces"
      min_lines: 20
    - path: "src/processors/delete-builder.ts"
      provides: "buildDeleteOps() function"
      exports: ["buildDeleteOps"]
  key_links:
    - from: "src/processors/delete-builder.ts"
      to: "@geoprotocol/geo-sdk"
      via: "Graph.deleteRelation() and Graph.updateEntity()"
      pattern: "Graph\\.(deleteRelation|updateEntity)"
    - from: "src/processors/delete-builder.ts"
      to: "src/api/geo-client.ts"
      via: "EntityDetails type import"
      pattern: "import.*EntityDetails.*geo-client"
---

<objective>
Create the delete operation builder that converts EntityDetails[] into Geo SDK Op[] for blanking entities.

Purpose: This is the core business logic of the delete pipeline -- transforming fetched entity data into the correct sequence of SDK operations (deleteRelation for all relations, updateEntity with unset for all properties). This must handle the critical "deleteEntity is non-functional" workaround.

Output: `src/processors/delete-builder.ts` (op builder) and `src/config/delete-types.ts` (delete-specific types)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bulk-delete/02-RESEARCH.md

Key reference files:
@src/api/geo-client.ts (EntityDetails interface -- the input type)
@src/config/types.ts (DeleteReport interface -- the report shape)
@src/config/upsert-types.ts (OperationsBatch pattern -- follow for DeleteBatch)
@src/processors/batch-builder.ts (reference for how upsert builds Op[])
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delete-specific type definitions</name>
  <files>src/config/delete-types.ts</files>
  <action>
Create `src/config/delete-types.ts` with delete-specific types following the pattern of `upsert-types.ts`:

```typescript
import type { Op } from '@geoprotocol/geo-sdk';

/** Options for the delete command (parsed from CLI flags) */
export interface DeleteOptions {
  network?: string;
  space: string;         // Required --space flag (32-char hex)
  dryRun: boolean;
  output: string;        // Report output directory
  verbose: boolean;
  force: boolean;        // --force skips confirmation
}

/** Summary of delete operations built */
export interface DeleteSummary {
  entitiesProcessed: number;
  relationsToDelete: number;
  propertiesToUnset: number;
  backlinksToDelete: number;
}

/** Batch of delete operations ready for publishing */
export interface DeleteBatch {
  ops: Op[];
  summary: DeleteSummary;
}

/** Pre-deletion snapshot of entity data for audit trail */
export interface DeleteSnapshot {
  timestamp: string;
  entities: Array<{
    id: string;
    name: string | null;
    propertyCount: number;
    relationCount: number;
    backlinkCount: number;
    typeIds: string[];
  }>;
  snapshotPath: string;
}
```

Keep types minimal and focused. Do NOT import from upsert-types.ts. The `Op` type comes from `@geoprotocol/geo-sdk`.
  </action>
  <verify>
    <automated>cd /Users/Vytautas/Documents/GitHub/spreadsheet-to-geo && npx tsc --noEmit</automated>
    <manual>Check that delete-types.ts exports DeleteOptions, DeleteSummary, DeleteBatch, DeleteSnapshot</manual>
  </verify>
  <done>delete-types.ts exists with DeleteOptions, DeleteSummary, DeleteBatch, and DeleteSnapshot interfaces exported</done>
</task>

<task type="auto">
  <name>Task 2: Create delete operation builder</name>
  <files>src/processors/delete-builder.ts</files>
  <action>
Create `src/processors/delete-builder.ts` that converts `EntityDetails[]` into a `DeleteBatch`.

**CRITICAL:** Do NOT use `Graph.deleteEntity()` -- the Indexer ignores it. Use `Graph.deleteRelation()` for all relations and `Graph.updateEntity({ id, unset })` for all properties.

Implementation:

```typescript
import { Graph } from '@geoprotocol/geo-sdk';
import type { Op } from '@geoprotocol/geo-sdk';
import type { EntityDetails } from '../api/geo-client.js';
import type { DeleteBatch, DeleteSummary } from '../config/delete-types.js';

/**
 * Build delete operations for a list of entities.
 *
 * For each entity:
 * 1. Delete all outgoing relations (includes type assignments) via Graph.deleteRelation()
 * 2. Delete all incoming relations (backlinks) via Graph.deleteRelation()
 * 3. Unset all property values via Graph.updateEntity({ id, unset })
 *
 * Maintains a Set<string> of already-processed relation IDs to handle the case
 * where the same relation appears as an outgoing relation on entity A and a
 * backlink on entity B (both in the input list). Each relation is deleted only once.
 *
 * NOTE: Graph.deleteEntity() is NOT used -- the Indexer ignores it.
 * The entity "shell" remains but appears blank (no properties, no relations).
 */
export function buildDeleteOps(entities: EntityDetails[]): DeleteBatch {
  const allOps: Op[] = [];
  const processedRelationIds = new Set<string>();
  let totalRelations = 0;
  let totalBacklinks = 0;
  let totalProperties = 0;

  for (const entity of entities) {
    // 1. Delete outgoing relations (includes type assignment relations)
    for (const rel of entity.relations) {
      if (processedRelationIds.has(rel.id)) continue;
      processedRelationIds.add(rel.id);
      const { ops } = Graph.deleteRelation({ id: rel.id });
      allOps.push(...ops);
      totalRelations++;
    }

    // 2. Delete incoming relations (backlinks / "Referenced by")
    for (const backlink of entity.backlinks) {
      if (processedRelationIds.has(backlink.id)) continue;
      processedRelationIds.add(backlink.id);
      const { ops } = Graph.deleteRelation({ id: backlink.id });
      allOps.push(...ops);
      totalBacklinks++;
    }

    // 3. Unset ALL property values (blanks the entity)
    const propertyIds = [...new Set(entity.values.map(v => v.propertyId))];
    if (propertyIds.length > 0) {
      const { ops } = Graph.updateEntity({
        id: entity.id,
        unset: propertyIds.map(property => ({ property })),
      });
      allOps.push(...ops);
      totalProperties += propertyIds.length;
    }
  }

  const summary: DeleteSummary = {
    entitiesProcessed: entities.length,
    relationsToDelete: totalRelations,
    propertiesToUnset: totalProperties,
    backlinksToDelete: totalBacklinks,
  };

  return { ops: allOps, summary };
}
```

**Key details:**
- Import `Graph` from `@geoprotocol/geo-sdk` (same import pattern as existing code)
- Import `EntityDetails` from `../api/geo-client.js` (the `.js` extension is required for ESM)
- The `processedRelationIds` Set handles Pitfall 3 from RESEARCH.md (duplicate relation deletions across entities)
- Property dedup via `new Set()` ensures each property is unset only once per entity even if it has multiple values
- Return type is `DeleteBatch` (ops + summary) following the same pattern as `OperationsBatch` from upsert

Do NOT add any console output or logging here -- this is a pure function. Logging belongs in the command handler.
  </action>
  <verify>
    <automated>cd /Users/Vytautas/Documents/GitHub/spreadsheet-to-geo && npx tsc --noEmit</automated>
    <manual>Verify buildDeleteOps is exported and uses Graph.deleteRelation + Graph.updateEntity (not Graph.deleteEntity)</manual>
  </verify>
  <done>delete-builder.ts exports buildDeleteOps() that produces Op[] from EntityDetails[], using Graph.deleteRelation() for relations and Graph.updateEntity({ unset }) for properties, with relation ID deduplication across entities</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `src/processors/delete-builder.ts` exists and exports `buildDeleteOps`
3. `src/config/delete-types.ts` exists and exports `DeleteOptions`, `DeleteSummary`, `DeleteBatch`, `DeleteSnapshot`
4. No usage of `Graph.deleteEntity()` anywhere in the new files
5. `buildDeleteOps()` uses `Graph.deleteRelation()` for outgoing relations, backlinks, and `Graph.updateEntity({ unset })` for properties
6. Relation ID deduplication via Set prevents duplicate deletions across entities
</verification>

<success_criteria>
- TypeScript compiles without errors
- Delete builder correctly converts EntityDetails[] to Op[] using the Graph.deleteRelation() + Graph.updateEntity({ unset }) workaround
- Relation dedup handles the case where the same relation appears as outgoing on entity A and backlink on entity B
- No usage of Graph.deleteEntity() (it is non-functional)
</success_criteria>

<output>
After completion, create `.planning/phases/02-bulk-delete/02-01-SUMMARY.md`
</output>
